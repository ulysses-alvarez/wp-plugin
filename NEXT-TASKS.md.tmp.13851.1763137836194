# ğŸ“‹ TAREAS PENDIENTES - PROPERTY MANAGER

## ğŸ”´ ALTA PRIORIDAD

### ğŸ› 1. BUG CRÃTICO: Cambio de Nombre y ContraseÃ±a NO se Persisten en Base de Datos

**Problema:**
Aunque el request al API devuelve status 200 y mensaje de Ã©xito, los cambios de nombre y contraseÃ±a NO se guardan en la base de datos de WordPress. El usuario puede cambiar su nombre o contraseÃ±a, ve el toast de Ã©xito, pero:
- El nombre sigue siendo el anterior en el frontend y wp-admin
- La contraseÃ±a antigua sigue funcionando, la nueva NO funciona

**Evidencia de logs:**
```javascript
// Request exitoso:
Profile update response: {status: 200, data: {success: true, message: 'Perfil actualizado correctamente'}}

// Pero al recargar:
Profile loaded: {name: "Ul Test Admin", ...} // âŒ Nombre NO cambiÃ³ a "Fernando DÃ­az"
```

**Causa raÃ­z probable:**
El API responde con Ã©xito pero `wp_update_user()` puede estar fallando silenciosamente o los datos no se estÃ¡n actualizando correctamente en WordPress.

**Ubicaciones a investigar:**
- **Backend:** `property-manager/includes/class-property-profile-api.php` lÃ­neas 126-176
- EspecÃ­ficamente la llamada a `wp_update_user($user_data)` lÃ­nea 176
- Verificar si hay hooks de WordPress bloqueando la actualizaciÃ³n
- Verificar permisos del usuario actual

**SoluciÃ³n propuesta:**
1. Agregar logs en el backend PHP antes y despuÃ©s de `wp_update_user()`
2. Verificar el resultado de `wp_update_user()` y registrar si devuelve `WP_Error`
3. Verificar que `$user_data` contenga los campos correctos
4. Revisar si hay algÃºn hook de WordPress interceptando la actualizaciÃ³n
5. Confirmar que el usuario tiene permisos para actualizar su propio perfil

**Impacto:** ğŸ”´ CRÃTICO - Los usuarios NO pueden cambiar su informaciÃ³n de perfil

**Estado:** âŒ Requiere investigaciÃ³n backend

---

### âœ… 2. BUG RESUELTO: Rol Aparece Correctamente en PÃ¡gina de Perfil

**Problema original:**
El campo "Rol" NO se mostraba en la pÃ¡gina de perfil.

**SoluciÃ³n implementada:**
- Agregado mapeo de datos en el frontend para soportar tanto `role_label` como `roleLabel`
- Modificado API para devolver ambos formatos
- Archivos modificados:
  - `src/pages/ProfilePage.tsx` lÃ­neas 60-67
  - `property-manager/includes/class-property-profile-api.php` lÃ­neas 67-68

**Estado:** âœ… Completado y funcional

---

### âŒ 3. Scroll AutomÃ¡tico en PaginaciÃ³n (NO FUNCIONA)

**Problema:**
Cuando el usuario estÃ¡ navegando por la tabla de propiedades y hace scroll hasta abajo, al cambiar de pÃ¡gina la vista NO sube automÃ¡ticamente al inicio de la tabla. El usuario se queda viendo el final de la pÃ¡gina vacÃ­a.

**Impacto en UX:** Alto - Confunde al usuario haciÃ©ndole pensar que no hay mÃ¡s propiedades.

---

#### ğŸ“Š AnÃ¡lisis TÃ©cnico Completo

**Estructura del DOM:**
```
PropertiesPage
  â””â”€â”€ <div className="h-full flex flex-col">
      â”œâ”€â”€ <PropertyFilters />
      â””â”€â”€ <div className="flex-1 overflow-auto">  â† CONTENEDOR SCROLLABLE REAL (PropertiesPage lÃ­nea 529)
          â””â”€â”€ <div className="px-4 sm:px-6 lg:px-8 py-6 h-full flex flex-col">
              â””â”€â”€ <div className="flex-1 overflow-hidden">
                  â””â”€â”€ <PropertyTable>
                      â””â”€â”€ <div ref={tableContainerRef} className="h-full flex flex-col">
                          â””â”€â”€ <div className="flex-1 overflow-hidden flex flex-col">
                              â””â”€â”€ <div className="flex-1 overflow-auto">  â† Scroll interno de tabla
```

---

#### ğŸ”„ Historial de Intentos de SoluciÃ³n

##### **Intento #1 - CÃ³digo Original (ANTES)**
**UbicaciÃ³n:** `PropertyTable.tsx` lÃ­neas 154-172 (versiÃ³n previa)

```typescript
const handlePageChange = (page: number) => {
  setPage(page);

  // Execute scroll after a small delay to ensure content is updated
  requestAnimationFrame(() => {
    // Find all scrollable elements and scroll them to top
    const scrollableElements = [
      document.querySelector('.overflow-auto'),
      document.documentElement,
      document.body
    ];

    scrollableElements.forEach((element) => {
      if (element) {
        element.scrollTo({ top: 0, behavior: 'smooth' });
      }
    });
  });
};
```

**Por quÃ© no funcionÃ³:**
- `document.querySelector('.overflow-auto')` encuentra el PRIMER elemento con esa clase
- Puede encontrar el scroll interno de la tabla en lugar del contenedor padre
- No garantiza que sea el contenedor correcto
- Intenta mÃºltiples elementos pero sin especificidad

---

##### **Intento #2 - Uso de `.closest()` (ACTUAL - NO FUNCIONA)**
**UbicaciÃ³n:** `PropertyTable.tsx` lÃ­neas 154-170 (versiÃ³n actual)

```typescript
const handlePageChange = (page: number) => {
  setPage(page);

  // Scroll to top after page change
  // Use requestAnimationFrame to ensure the page change is processed first
  requestAnimationFrame(() => {
    // Find the scrollable parent container (the one in PropertiesPage)
    if (tableContainerRef.current) {
      // Find the closest parent element with overflow-auto class
      const scrollableParent = tableContainerRef.current.closest('.overflow-auto');
      
      if (scrollableParent) {
        scrollableParent.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }
  });
};
```

**Por quÃ© probablemente no funciona:**
1. **Timing incorrecto:** `requestAnimationFrame` puede ejecutarse antes de que React actualice el DOM
2. **Ref incorrecto:** `tableContainerRef` estÃ¡ dentro de muchos niveles de divs anidados
3. **`.closest()` busca hacia arriba:** PodrÃ­a encontrar el contenedor interno de la tabla primero
4. **Estado asÃ­ncrono:** `setPage()` es asÃ­ncrono y el scroll se ejecuta antes de que las propiedades se carguen

---

#### ğŸ”§ Posibles Soluciones a Explorar

##### **OpciÃ³n A: useEffect con dependencia en currentPage**
```typescript
useEffect(() => {
  // Ejecutar despuÃ©s de que currentPage cambie y las propiedades se carguen
  if (!initialLoad && !loading) {
    const scrollContainer = document.querySelector('.flex-1.overflow-auto');
    if (scrollContainer) {
      scrollContainer.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }
}, [currentPage, loading, initialLoad]);
```

**Ventajas:**
- Se ejecuta despuÃ©s de que React actualice el DOM
- Depende de `currentPage` que cambia cuando se navega
- Verifica que no estÃ© cargando

**Desventajas:**
- Puede ejecutarse en otras situaciones
- Necesita selectores mÃ¡s especÃ­ficos

---

##### **OpciÃ³n B: Pasar ref desde PropertiesPage**
```typescript
// En PropertiesPage.tsx
const mainScrollContainerRef = useRef<HTMLDivElement>(null);

// Luego en el JSX:
<div ref={mainScrollContainerRef} className="flex-1 overflow-auto">
  ...
  <PropertyTable scrollContainerRef={mainScrollContainerRef} />
</div>

// En PropertyTable.tsx
interface PropertyTableProps {
  scrollContainerRef?: React.RefObject<HTMLDivElement>;
  // ... otros props
}

const handlePageChange = (page: number) => {
  setPage(page);
  
  requestAnimationFrame(() => {
    if (scrollContainerRef?.current) {
      scrollContainerRef.current.scrollTo({ top: 0, behavior: 'smooth' });
    }
  });
};
```

**Ventajas:**
- Acceso directo al contenedor correcto
- No depende de selectores CSS
- MÃ¡s predecible

**Desventajas:**
- Requiere modificar la interfaz del componente
- Acopla mÃ¡s los componentes

---

##### **OpciÃ³n C: Usar scrollIntoView en el primer elemento de la tabla**
```typescript
const handlePageChange = (page: number) => {
  setPage(page);
  
  // Esperar a que React actualice
  setTimeout(() => {
    // Buscar la primera fila de la tabla o el header
    const firstElement = tableContainerRef.current?.querySelector('thead') 
                      || tableContainerRef.current?.querySelector('tbody tr:first-child');
    
    if (firstElement) {
      firstElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }, 100);
};
```

**Ventajas:**
- Usa el navegador para encontrar el contenedor scrollable automÃ¡ticamente
- `scrollIntoView` es mÃ¡s confiable
- Scroll al elemento especÃ­fico (header de tabla)

**Desventajas:**
- Usa `setTimeout` con tiempo arbitrario
- Puede no funcionar si el DOM no estÃ¡ listo

---

##### **OpciÃ³n D: Callback despuÃ©s de loadProperties**
```typescript
const handlePageChange = (page: number) => {
  setPage(page);
  
  // Esperar a que loadProperties termine
  loadProperties().then(() => {
    requestAnimationFrame(() => {
      const scrollContainer = document.querySelector('.flex-1.overflow-auto');
      if (scrollContainer) {
        scrollContainer.scrollTo({ top: 0, behavior: 'smooth' });
      }
    });
  });
};
```

**Ventajas:**
- Scroll despuÃ©s de que los datos se carguen
- Usa Promises para timing correcto

**Desventajas:**
- `loadProperties` ya se ejecuta por el `useEffect`
- PodrÃ­a causar doble carga

---

#### ğŸ“ Archivos Afectados

- **`src/components/properties/PropertyTable.tsx`** (lÃ­neas 154-170)
- **`src/components/properties/PropertyGrid.tsx`** (lÃ­neas 53-66)
- **`src/pages/PropertiesPage.tsx`** (lÃ­nea 529 - contenedor scrollable)

---

#### âœ… Criterios de Ã‰xito

1. Usuario hace scroll hasta el final de la tabla
2. Usuario hace clic en "PÃ¡gina 2" (o cualquier otra pÃ¡gina)
3. La vista debe subir suavemente al inicio de la tabla
4. El usuario debe ver la primera propiedad de la nueva pÃ¡gina inmediatamente

---

#### ğŸ¯ Prioridad: **ALTA**
#### â±ï¸ EstimaciÃ³n: 1-2 horas de investigaciÃ³n + pruebas

---

## ğŸŸ¢ COMPLETADAS

### âœ… 1. Estado VacÃ­o vs BÃºsqueda Sin Resultados

**Problema:** El botÃ³n "+ Agregar Primera Propiedad" aparecÃ­a incluso cuando se buscaba algo y no habÃ­a resultados.

**SoluciÃ³n implementada:**
- Se detecta si hay bÃºsqueda activa mediante `filters.searchValue`
- Si hay bÃºsqueda sin resultados: muestra mensaje de bÃºsqueda (sin botÃ³n)
- Si sistema vacÃ­o sin bÃºsqueda: muestra botÃ³n "+ Agregar Primera Propiedad"

**Archivos modificados:**
- `src/components/properties/PropertyTable.tsx` (lÃ­neas 250-294)
- `src/components/properties/PropertyGrid.tsx` (lÃ­neas 84-128)

**Estado:** âœ… Completado y funcional

---

## ğŸ“… Ãšltima actualizaciÃ³n: 2025-11-12

